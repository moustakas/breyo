#!/usr/bin/env python

"""Pipeline-reduce a single night of Breyo imaging.

The uncertainty stuff with CCDproc is a mess (mostly having to do with units),
plus what I really want is to create and store the inverse variance image, so
let's leave that for now.

Great reference code:
https://github.com/rgbIAA/reduceccd/blob/master/reduceccd/reduceccd.py

"""
import os, pdb
import argparse
import numpy as np
import numpy.ma as ma

import astropy.stats
import astropy.units as u
import astropy.table
import astropy.io
from astropy import wcs
from astropy.coordinates import SkyCoord
from astropy.nddata import CCDData

import ccdproc as ccdp

import breyo.io

image2type = {'Light Frame': 'object',
              'Dark Frame': 'dark',
              'Flat Field': 'flat',
              'Bias Frame': 'bias'}

newfilt = {'Blue': 'B',
           'Green': 'V',
           'Red': 'R',
           'OIII': 'OIII',
           'O3': 'OIII',
           'Ha': 'Halpha',
           'Halpha': 'Halpha',
           }

allfilt = ('B', 'V', 'R')

# From Table 6 of https://arxiv.org/pdf/1012.4804.pdf
# assume Landoldt and PanSTARRS filters and RV=3.1
mwextcoeff = dict(B=3.626, V=2.742, R=2.169,
                  g=3.172, r=2.271, i=1.682, z=1.322)

kext = {'B': 0.4, 'V': 0.2, 'R': 0.1}

def _inv_median(a):
    return 1 / np.median(a)
                
def main():
    """

    """
    parser = argparse.ArgumentParser()
    parser.add_argument('night', type=str, help='Specify the night to reduce.')
    parser.add_argument('--preproc', action='store_true', help='Preprocess the raw data.')
    parser.add_argument('--masterbias', action='store_true', help='Build the master bias frame.')
    parser.add_argument('--masterflats', action='store_true', help='Build the master (sky)flats.')
    parser.add_argument('--masterdarks', action='store_true', help='Build the master darks.')

    parser.add_argument('--reduceall', action='store_true', help='Process the science images.')
    parser.add_argument('--crzap', action='store_true', help='Zap cosmic rays')
    parser.add_argument('--astrometry', action='store_true', help='Solve the astrometry.')
    parser.add_argument('--refstars', action='store_true', help='Generate reference photometric catalog.')
    parser.add_argument('--photcalib', action='store_true', help='Photometrically calibrate.')
    parser.add_argument('--reproject', action='store_true', help='(Re)project onto a tangent plane.')
    parser.add_argument('--stack', action='store_true', help='Build image stacks.')

    parser.add_argument('--verbose', action='store_true', help='Be verbose.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing files.')
    args = parser.parse_args()

    rawdir = breyo.io.get_rawdir(args.night)
    reduxdir, calibdir = breyo.io.get_reduxdir(args.night)
    config = breyo.io.read_config()

    masterbiasfile = os.path.join(reduxdir, 'master-bias.fits')

    # ToDo: building uncertainty map and bad pixel mask
    # https://ccdproc.readthedocs.io/en/latest/reduction_toolbox.html#gain-correct-and-create-deviation-image
    # https://mwcraig.github.io/ccd-as-book/08-00-Image-masking.html
    if args.preproc:
        keys = ['naxis1', 'naxis2', 'imagetyp', 'filter', 'exptime']
        ic = ccdp.ImageFileCollection(rawdir, keywords=keys, glob_include='*.fit*',
                                      glob_exclude='*test*.fit')
        print('Parsing {} files in {}'.format(len(ic.files), rawdir))
        if args.verbose:
            print(ic.summary)

        for exp, fname in ic.hdus(return_fname=True):
            rawfile = os.path.join(rawdir, fname)
            hdr = exp.header
            imtype = image2type[hdr['IMAGETYP']]

            # basic sanity checks
            if (imtype == 'object' or imtype == 'flat') and 'FILTER' not in hdr:
                print('Missing FILTER in image {}'.format(rawfile))
                continue

            if hdr['NAXIS2'] < 1000:
                print('Subframe issue in image {}'.format(rawfile))
                continue

            if hdr['XBINNING'] != 2:
                print('Cannot yet handle unbinned imaging.')
                continue

            # push these cases to a function
            if imtype == 'bias' or imtype == 'dark' or imtype == 'flat':
                outfile = os.path.join(calibdir, fname.replace('.fit', '.fits'))
            else:
            #    filt = newfilt[hdr['FILTER']].strip()
            #    obj = hdr['OBJECT'].strip()
            #    outfile = os.path.join(reduxdir, '{}-{}.fits'.format(obj, filt))
                 outfile = os.path.join(reduxdir, 'p-{}'.format(fname.replace('.fit', '.fits')))
                
            if os.path.isfile(outfile) and not args.overwrite:
                print('Skipping existing file {}'.format(outfile))
            else:
                # update the header
                hdr['IMAGETYP'] = imtype
                if 'FILTER' in hdr:
                    try:
                        hdr['FILTER'] = newfilt[hdr['FILTER']]
                    except KeyError: # this is raised for example if color image is in directory
                        print('WARNING: FILTER {} not recognized.  \n\tMaybe move {} to junk after preproc'.format(hdr['FILTER'],fname))
                img = CCDData(data=exp.data.astype('f4'), meta=hdr, unit=u.adu)

                # Do not create the uncertainty array here so we're not carrying
                # around extra bits; do it below in --reduceall (just for the
                # science images, obviously).
                
                #if imtype == 'object':
                #    img = ccdp.create_deviation(img, gain=config['ccd']['gain'],
                #                                readnoise=config['ccd']['readnoise'],
                #                                disregard_nan=True, add_keyword={'CREATVAR': True})
                img = ccdp.gain_correct(img, gain=config['ccd']['gain'],
                                        add_keyword={'GAINCOR': True})

                # ToDo: generalize the trimming!
                img = ccdp.trim_image(img[:, 50:], add_keyword={'TRIM': True})

                print('Writing {}'.format(outfile))
                img.write(outfile, overwrite=True)

    if args.masterbias:
        if os.path.isfile(masterbiasfile) and not args.overwrite:
            print('Skipping existing master bias {}'.format(masterbiasfile))
        else:
            keys = ['naxis1', 'naxis2', 'imagetyp', 'exptime']
            ic = ccdp.ImageFileCollection(calibdir, keywords=keys, glob_include='bias*.fits')
            if args.verbose:
                print(ic.summary)

            biasfiles = ic.files_filtered(include_path=True)
            nbias = len(biasfiles)
            print('Building master bias from {} images in {}'.format(nbias, calibdir))

            rbias = []
            for biasfile in biasfiles:
                bias = CCDData.read(biasfile)
                rbias.append(bias)

            masterbias = ccdp.combine(rbias,
                                      method='average', sigma_clip=True,
                                      sigma_clip_low_thresh=5, 
                                      sigma_clip_high_thresh=5,
                                      sigma_clip_func=np.ma.median,
                                      sigma_clip_dev_func=astropy.stats.mad_std)
            masterbias.data = masterbias.data.astype('f4')
            masterbias.header['NBIAS'] = nbias
            masterbias.header['COMBINED'] = True

            print('  Writing {}'.format(masterbiasfile))
            masterbias.write(masterbiasfile, overwrite=True)

    if args.masterdarks:
        print('Reading {}'.format(masterbiasfile))
        masterbias = CCDData.read(masterbiasfile)

        keys = ['file', 'imagetyp', 'exptime', 'filter']
        ic = ccdp.ImageFileCollection(calibdir, keywords=keys, glob_include='dark*.fits')
        if args.verbose:
            print(ic.summary)
        exptimes = sorted(set(ic.summary['exptime']))

        for exptime in exptimes:
            masterdarkfile = os.path.join(reduxdir, 'master-dark-{:.1f}s.fits'.format(exptime))
            if os.path.isfile(masterdarkfile) and not args.overwrite:
                print('Skipping existing master dark {}'.format(masterdarkfile))
            else:
                darkfiles = ic.files_filtered(exptime=exptime, include_path=True)
                ndark = len(darkfiles)
                print('Building {:.1f} sec masterdark from {} images found in {}'.format(exptime, ndark, calibdir))

                rdarks = []
                for darkfile in darkfiles:
                    dark = CCDData.read(darkfile)
                    dark = ccdp.subtract_bias(dark, masterbias, add_keyword={'SUBBIAS': True})
                    rdarks.append( dark )
                    
                masterdark = ccdp.combine(rdarks,
                                          method='average',
                                          sigma_clip=True,
                                          sigma_clip_low_thresh=5, 
                                          sigma_clip_high_thresh=5,
                                          sigma_clip_func=np.ma.median,
                                          sigma_clip_dev_func=astropy.stats.mad_std)
                masterdark.data = masterdark.data.astype('f4')
                masterdark.header['NDARK'] = ndark
                masterdark.header['COMBINED'] = True

                print('  Writing {}'.format(masterdarkfile))
                masterdark.write(masterdarkfile, overwrite=True)

    if args.masterflats:
        print('Reading {}'.format(masterbiasfile))
        masterbias = CCDData.read(masterbiasfile)

        keys = ['file', 'imagetyp', 'exptime', 'filter']
        ic = ccdp.ImageFileCollection(calibdir, keywords=keys, glob_include='skyflat*.fits')
        for filt in set(ic.summary['filter']):
            masterflatfile = os.path.join(reduxdir, 'master-flat-{}.fits'.format(filt))
            if os.path.isfile(masterflatfile) and not args.overwrite:
                print('Skipping existing master flat {}'.format(masterflatfile))
            else:
                flatfiles = ic.files_filtered(imagetyp='flat', filter=filt, include_path=True)
                nflat = len(flatfiles)
                print('Building {} masterflat from {} images found in {}'.format(filt, nflat, calibdir))

                rflats = []
                for flatfile in flatfiles:
                    flat = CCDData.read(flatfile)
                    flat = ccdp.subtract_bias(flat, masterbias, add_keyword={'SUBBIAS': True})
                    rflats.append(flat)
                    
                masterflat = ccdp.combine(rflats,
                                          method='average', scale=_inv_median,
                                          sigma_clip=True,
                                          sigma_clip_low_thresh=5, 
                                          sigma_clip_high_thresh=5,
                                          sigma_clip_func=np.ma.median,
                                          sigma_clip_dev_func=astropy.stats.mad_std)
                masterflat.data = masterflat.data.astype('f4')
                masterflat.header['NFLAT'] = nflat
                masterflat.header['COMBINED'] = True

                print('  Writing {}'.format(masterflatfile))
                masterflat.write(masterflatfile, overwrite=True)

    if args.reduceall:
        print('Reading {}'.format(masterbiasfile))
        masterbias = CCDData.read(masterbiasfile)

        keys = ['file', 'naxis1', 'naxis2', 'object', 'imagetyp', 'filter', 'exptime']
        ic = ccdp.ImageFileCollection(reduxdir, keywords=keys, glob_include='p-*.fits')
                                      
        if args.verbose:
            print(ic.summary)
        
        for filt in set(ic.summary['filter']):
            # throw an error if not found
            masterflatfile = os.path.join(reduxdir, 'master-flat-{}.fits'.format(filt))
            print('Reading {}'.format(masterflatfile))
            masterflat = CCDData.read(masterflatfile)
            
            icfilt = ic.filter(filter=filt)
            #fnames = ic.files_filtered(filter=filt)#, include_path=True)
            #for fname in fnames:
            for ccd, fname in icfilt.ccds(return_fname=True):
                outfile = os.path.join(reduxdir, 'fb{}'.format(fname))
                if os.path.isfile(outfile) and not args.overwrite:
                    print('Skipping existing file {}'.format(outfile))
                else:
                    # deal with uncertainties later
                    #img = CCDData.read(os.path.join(reduxdir, fname))
                    #img.data = img.divide(config['ccd']['gain'])
                    #img = ccdp.create_deviation(img, gain=config['ccd']['gain'],
                    #                            readnoise=config['ccd']['readnoise'],
                    #                            disregard_nan=True, add_keyword={'CREATVAR': True})
                    #img.data = img.data.multiply(config['ccd']['gain'])

                    #img = ccdp.subtract_bias(img, masterbias,
                    #                         add_keyword={
                    #                             'SUBBIAS': True,
                    #                             'BIASFILE': os.path.basename(masterbiasfile),
                    #                             })
                    #img = ccdp.flat_correct(img, masterflat, 
                    #                        add_keyword={
                    #                            'FLATCOR': True,
                    #                            'FLATFILE': os.path.basename(masterflatfile),
                    #                            })
                                        
                    outccd = ccdp.ccd_process(ccd,
                                              gain_corrected=True,
                                              #error=True,
                                              min_value=0.9,
                                              #gain=config['ccd']['gain'],
                                              #readnoise=config['ccd']['readnoise'],
                                              master_bias=masterbias,
                                              master_flat=masterflat,
                                              add_keyword={
                                                  'CREATVAR': True,
                                                  'SUBBIAS': True,
                                                  'FLATCOR': True,
                                                  'BIASFILE': os.path.basename(masterbiasfile),
                                                  'FLATFILE': os.path.basename(masterflatfile),
                                                  })
                    print('  Writing {}'.format(outfile))
                    outccd.write(outfile, overwrite=True)

    if args.crzap:
        keys = ['file', 'naxis1', 'naxis2', 'object', 'imagetyp', 'filter', 'exptime']
        ic = ccdp.ImageFileCollection(reduxdir, keywords=keys, glob_include='fbp-*.fits')
                                      
        if args.verbose:
            print(ic.summary)
        
        for ccd, fname in ic.ccds(return_fname=True):
            outfile = os.path.join(reduxdir, 'z{}'.format(fname))
            if os.path.isfile(outfile) and not args.overwrite:
                print('Skipping existing file {}'.format(outfile))
            else:
               zccd = ccdp.cosmicray_lacosmic(ccd, sigclip=7, verbose=args.verbose)#,
                                              #readnoise=config['ccd']['readnoise'])

               print('  Writing {}'.format(outfile))
               zccd.write(outfile, overwrite=True)

    if args.astrometry:
        import subprocess
        
        configfile = os.path.join(os.getenv('BREYO_DATA_DIR'), 'astrometry.net', 'index-5000', 'cfg')

        keys = ['file', 'object', 'imagetyp', 'filter', 'exptime']
        #ic = ccdp.ImageFileCollection(reduxdir, keywords=keys, glob_include='zfbp-*.fits')
        ic = ccdp.ImageFileCollection(reduxdir, keywords=keys, glob_include='zfbp-*.fits')
        for fname in ic.files_filtered(include_path=True):

            outfile = os.path.join(reduxdir, 'a{}'.format(os.path.basename(fname)))
            if os.path.isfile(outfile) and not args.overwrite:
                print('Skipping existing file {}'.format(outfile))
            else:
                hdr = astropy.io.fits.getheader(fname)
                c = SkyCoord(hdr['OBJCTRA']+hdr['OBJCTDEC'], unit=(u.hourangle, u.deg))
                ra, dec = c.ra.value, c.dec.value
                axyfile = outfile.replace('.fits', '.axy')
                #wcsfile = '$(mktemp /tmp/{}.wcs)'.format(os.path.basename(outfile).replace('.fits', ''))

                cmd =  'solve-field {scifile} --config {configfile} --ra {ra} --dec {dec} '
                cmd += '--scale-low 0.5 --scale-high 1.0 --scale-units arcsecperpix '
                cmd += '--radius 0.5 --tweak-order 2 --crpix-center --nsigma 10 --objs 100 '
                cmd += '--solved none --index-xyls none --match none '
                cmd += '--rdls none --corr none --axy {axyfile} ' # --temp-axy
                cmd += '--new-fits {outfile} --downsample 2 ' # --wcs {wcsfile} '
                cmd += '--no-verify --no-plots --overwrite '
                cmd = cmd.format(scifile=fname, outfile=outfile, axyfile=axyfile,
                                 #wcsfile=wcsfile,
                                 configfile=configfile, ra=ra, dec=dec)
                if args.verbose:
                    print(cmd)
                err = subprocess.call(cmd.split())

    # Gather up reference stars.
    if args.refstars:
        from breyo.dust import SFDMap
        from breyo.photo import find_stars, get_panstarrs_catalog

        matchrad = 2 * u.arcsec

        keys = ['file', 'object', 'imagetyp', 'filter', 'exptime']
        ic = ccdp.ImageFileCollection(reduxdir, keywords=keys, glob_include='azfbp-*.fits')
        if args.verbose:
            print(ic.summary)

        for hdu, fname in ic.hdus(return_fname=True):

            outfile = os.path.join(reduxdir, 'refstars-{}-{}'.format(hdu.header['FILTER'], fname))
            if os.path.isfile(outfile) and not args.overwrite:
                print('Skipping existing file {}'.format(outfile))
            else:
                # For some reason, ccdproc doesn't read the full astrometry.net header.
                hdr = astropy.io.fits.getheader(os.path.join(reduxdir, fname))
                imgwcs = wcs.WCS(hdr)
                img = hdu.data # [electron]

                # find stars in the image
                srcs = find_stars(img, nsigma=5, fwhm=2.0, verbose=args.verbose)

                # query for reference stars
                # https://astroquery.readthedocs.io/en/latest/mast/mast.html
                # https://outerspace.stsci.edu/display/PANSTARRS/PS1+MeanObjectView+table+fields
                refsrcs = get_panstarrs_catalog(imgwcs, radius=0.3, verbose=args.verbose)

                # match them, merge the tables, and write out
                radec_stars = imgwcs.all_pix2world(srcs['xcentroid']+1, srcs['ycentroid']+1, 1)
                refcoord = SkyCoord(ra=refsrcs['raMean'] * u.deg, dec=refsrcs['decMean'] * u.deg)
                coord = SkyCoord(ra=radec_stars[0] * u.deg, dec=radec_stars[1] * u.deg)

                indx_ref, indx, d2d, _ = coord.search_around_sky(refcoord, matchrad)
                nstar = len(indx_ref)
                if args.verbose:
                    print('Found {}/{} stars within {}'.format(nstar, len(srcs), matchrad))

                out = astropy.table.hstack((refsrcs[indx_ref], srcs[indx]))
                out.add_column(astropy.table.Column(name='airmass', dtype='f4',
                                                    data=np.repeat(hdu.header['AIRMASS'], nstar)))
                out.add_column(astropy.table.Column(name='exptime', dtype='f4',
                                                    data=np.repeat(hdu.header['EXPTIME'], nstar)))
                out.add_column(astropy.table.Column(data=np.repeat(hdu.header['DATE-OBS'], nstar),
                                                    name='date-obs'))

                # add MW dust
                out.add_column(astropy.table.Column(name='ebv', length=nstar, dtype='f4'))
                out['ebv'] = SFDMap().ebv(out['raMean'], out['decMean'], unit=u.deg,
                                          frame='icrs', scaling=1.0)
                for filt in mwextcoeff.keys():
                    ext = mwextcoeff[filt] * out['ebv']
                    #out.add_column(astropy.table.Column(name='mw_transmission_{}'.format(filt),
                    #                                    dtype='f4', data=ext))
                    out.add_column(astropy.table.Column(name='mw_{}'.format(filt), dtype='f4', data=ext))

                # write out
                outhdu = astropy.io.fits.convenience.table_to_hdu(out)
                outhdu.header['EXTNAME'] = 'REFSTARS'
                for key in ('DATE-OBS', 'EXPTIME', 'AIRMASS', 'FILTER'):
                    outhdu.header[key] = (hdu.header[key], hdu.header.comments[key])

                print('Writing {} reference stars to {}'.format(len(out), outfile))
                outhdu.writeto(outfile, overwrite=True)

    if args.photcalib:
        ### this routine is not complete yet
        keys = ['file', 'object', 'imagetyp', 'filter', 'exptime']
        ic = ccdp.ImageFileCollection(reduxdir, keywords=keys, glob_include='azfbp-*.fits')
        if args.verbose:
            print(ic.summary)

        for filt in allfilt:

            icfilt = ic.filter(filter=filt)
            for hdu, fname in icfilt.hdus(return_fname=True):

                imgwcs = wcs.WCS(hdu.header)
                airmass, exptime = hdu.header['AIRMASS'], hdu.header['EXPTIME']
                img = hdu.data / exptime # [electron/s]

                #pdb.set_trace()

                # solve for zeropoint

                # save with prefix 'c'

    if args.reproject:
        # https://ccdproc.readthedocs.io/en/latest/image_combination.html#clipping
        from reproject import reproject_interp
        #from ccdproc import wcs_project
        #from breyo.photo import reproject_one_image
        
        pixscale = 0.8 # [arcsec/pixel]
        imgsize = 2500 # [pixels]

        # this step should happen after photometric calibration (prefix "c")... 
        keys = ['file', 'object', 'imagetyp', 'filter', 'exptime']
        ic = ccdp.ImageFileCollection(reduxdir, keywords=keys, glob_include='cazfbp-*.fits')
        if len(ic.files) == 0:
            ic = ccdp.ImageFileCollection(reduxdir, keywords=keys, glob_include='azfbp-*.fits')
        
        # organize by unique object
        for obj in set(ic.summary['object']):
            icobj = ic.filter(object=obj)
            if args.verbose:
                print(icobj.summary)

            # get the average CRVAL
            allra, alldec = [], []
            for fname in icobj.files:
                hdr = astropy.io.fits.getheader(fname)
                allra.append(hdr['CRVAL1'])
                alldec.append(hdr['CRVAL2'])

            # should include a warning for wonky coordinates!
            crval = np.array([np.mean(allra), np.mean(alldec)])
            print('Working on {}, mean RA, Dec = {:.5f}, {:.5f}'.format(obj, crval[0], crval[1]))

            for ccd, fname in icobj.ccds(return_fname=True):
                outfile = os.path.join(reduxdir, 'u{}'.format(fname))
                if os.path.isfile(outfile) and not args.overwrite:
                        print('Skipping existing file {}'.format(outfile))
                else:
                    # For some reason, ccdproc doesn't read the full astrometry.net header.
                    hdr = astropy.io.fits.getheader(os.path.join(reduxdir, fname))
                    imgwcs = wcs.WCS(hdr)
                    #imgwcs = wcs.WCS(ccd.header)

                    for ii, hdr1 in enumerate(hdr.cards):
                        try:
                            if 'Original key: "END"' in hdr1[1]:
                                cut = ii
                                break
                        except:
                            pass
                        
                    # Need to figure out how to do this properly, including how
                    # to set 'latpole' to zero correctly!
                    if False:
                        ww = wcs.WCS(naxis=2)
                        ww.wcs.ctype = ['RA---TAN', 'DEC--TAN']
                        ww.wcs.crval = crval
                        ww.wcs.cdelt = np.array([-pixscale, pixscale]) / 3600 # [degree/pixel]
                        ww.wcs.crpix = np.array([imgsize, imgsize]) // 2.0 + 0.5
                        newhdr = hdr[:cut] + ww.to_header()

                    newhdr = hdr[:cut]
                    newhdr['NAXIS1'] = imgsize
                    newhdr['NAXIS2'] = imgsize
                    newhdr['WCSAXES'] = 2
                    newhdr['CTYPE1'] = 'RA---TAN'
                    newhdr['CTYPE2'] = 'DEC--TAN'
                    newhdr['CRPIX1'] = imgsize // 2.0 + 0.5
                    newhdr['CRPIX2'] = imgsize // 2.0 + 0.5
                    newhdr['CRVAL1'] = crval[0]
                    newhdr['CRVAL2'] = crval[1]
                    newhdr['CUNIT1'] = 'deg'
                    newhdr['CUNIT2'] = 'deg'
                    newhdr['LONPOLE'] = 180.0
                    newhdr['LATPOLE'] = 0.0
                    newhdr['CD1_2'] = 0.0
                    newhdr['CD2_1'] = 0.0
                    newhdr['CD1_1'] = -pixscale / 3600.0
                    newhdr['CD2_2'] =  pixscale / 3600.0
                    newhdr['RADESYSa'] = 'ICRS'

                    try:
                        #footprint, newimg, newhdr = reproject_one_image(hdu, pixscale=0.8)
                        newimg, footprint = reproject_interp((ccd.data, hdr), newhdr)
                        if np.sum(footprint) == 0:
                            print('  Failed to reproject {}'.format(fname))
                        else:
                            newimg = CCDData(newimg, header=newhdr, unit=newhdr['BUNIT'])
                            print('  Writing {}'.format(outfile))
                            newimg.write(outfile, overwrite=True)
                    except:
                        print('  Failed to reproject {}'.format(fname))

if __name__ == '__main__':
    main()
